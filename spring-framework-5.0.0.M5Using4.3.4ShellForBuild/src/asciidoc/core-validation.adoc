
[[validation]]
= 验证，数据绑定和类型转换(Validation, Data Binding, and Type Conversion)




[[validation-introduction]]
== 介绍(Introduction)

.JSR-303/JSR-349 Bean验证(JSR-303/JSR-349 Bean Validation)
****
Spring Framework 4.0 supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1
(JSR-349) in terms of setup support, also adapting it to Spring's `Validator` interface.

Spring Framework 4.0在安装支持方面支持Bean Validation 1.0（JSR-303）和Bean Validation 1.1（JSR-349），也适用于Spring的 `Validator` 接口。

An application can choose to enable Bean Validation once globally, as described in
<<validation-beanvalidation>>, and use it exclusively for all validation needs.

应用程序可以选择一次全局启用Bean验证，如<<validation-beanvalidation>>中所述，并将其专门用于所有验证需求。

An application can also register additional Spring `Validator` instances per
`DataBinder` instance, as described in <<validation-binder>>. This may be useful for
plugging in validation logic without the use of annotations.

应用程序还可以在 `DataBinder` 实例中注册其他Spring `Validator` 实例，如<<validation-binder>>中所述。这可能有助于插入验证逻辑而不须使用注解。
****

There are pros and cons for considering validation as business logic, and Spring offers
a design for validation (and data binding) that does not exclude either one of them.
Specifically validation should not be tied to the web tier, should be easy to localize
and it should be possible to plug in any validator available. Considering the above,
Spring has come up with a `Validator` interface that is both basic and eminently usable
in every layer of an application.

将验证视为业务逻辑有利有弊，而Spring提供了一种验证（和数据绑定）的设计，并不排除任何一种。具体的验证不应该与Web层绑定，应该易于本地化，并且应该可以插入任何可用的验证器。考虑到上述情况，Spring已经提出了一个 `Validator` 接口，它是基本的，在应用程序的每个层都可以使用。

Data binding is useful for allowing user input to be dynamically bound to the domain
model of an application (or whatever objects you use to process user input). Spring
provides the so-called `DataBinder` to do exactly that. The `Validator` and the
`DataBinder` make up the `validation` package, which is primarily used in but not
limited to the MVC framework.

数据绑定对于允许用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）是有用的。Spring提供了所谓的 `DataBinder` 来做到这一点。`验证器` 和 `DataBinder` 组成 `验证` 包，主要用于但不限于MVC框架。

The `BeanWrapper` is a fundamental concept in the Spring Framework and is used in a lot
of places. However, you probably will not have the need to use the `BeanWrapper`
directly. Because this is reference documentation however, we felt that some explanation
might be in order. We will explain the `BeanWrapper` in this chapter since, if you were
going to use it at all, you would most likely do so when trying to bind data to objects.

`BeanWrapper` 是Spring框架中的一个基本概念，用于很多地方。但是，您可能不需要直接使用 `BeanWrapper`。然而因为这是参考文档，我们觉得有些解释可能是有序的。我们将在本章中解释一下 `BeanWrapper`，因为如果要使用它，那么在尝试将数据绑定到对象时，你很有可能会这样做。

Spring's DataBinder and the lower-level BeanWrapper both use PropertyEditors to parse
and format property values. The `PropertyEditor` concept is part of the JavaBeans
specification, and is also explained in this chapter. Spring 3 introduces a
"core.convert" package that provides a general type conversion facility, as well as a
higher-level "format" package for formatting UI field values. These new packages may be
used as simpler alternatives to PropertyEditors, and will also be discussed in this
chapter.

Spring的DataBinder和底层的BeanWrapper都使用PropertyEditor来解析和格式化属性值。`PropertyEditor` 概念是JavaBeans规范的一部分，本章还将对此进行说明。Spring 3引入了一个“core.convert”软件包，它提供了一般的类型转换工具，以及一个用于格式化UI字段值的高层的“格式”软件包。这些新软件包可能被用作PropertyEditor的更简单的替代方法，本章还将讨论这些新的软件包。




[[validator]]
== 使用Spring Validator接口进行验证(Validation using Spring's Validator interface)

Spring features a `Validator` interface that you can use to validate objects. The
`Validator` interface works using an `Errors` object so that while validating,
validators can report validation failures to the `Errors` object.

Spring提供了一个 `Validator` 接口，可用于验证对象。`Validator` 接口使用 `Errors` 对象工作，以便在验证时，验证器可以将验证失败报告给 `Errors` 对象。

Let's consider a small data object:

我们来考虑一个小数据对象：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class Person {

		private String name;
		private int age;

		// the usual getters and setters...
	}
----

We're going to provide validation behavior for the `Person` class by implementing the
following two methods of the `org.springframework.validation.Validator` interface:

我们将通过实现 `org.springframework.validation.Validator` 接口的以下两个方法来为 `Person` 类提供验证行为：

* `supports(Class)` - Can this `Validator` validate instances of the supplied `Class`?
* `validate(Object, org.springframework.validation.Errors)` - validates the given object
  and in case of validation errors, registers those with the given `Errors` object

* `supports(Class)` - 这个 `验证器` 可以验证提供的 `Class` 的实例吗？
* `validate(Object, org.springframework.validation.Errors)` - 验证给定的对象，并在验证错误的情况下，注册给定的 `Errors` 对象

Implementing a `Validator` is fairly straightforward, especially when you know of the
`ValidationUtils` helper class that the Spring Framework also provides.

实现 `验证器` 是相当简单的，特别是当你知道Spring Framework还提供 `ValidationUtils` 帮助器类时。

[source,java,indent=0]
[subs="verbatim"]
----
	public class PersonValidator implements Validator {

		/**
		 * This Validator validates *just* Person instances
		 */
		public boolean supports(Class clazz) {
			return Person.class.equals(clazz);
		}

		public void validate(Object obj, Errors e) {
			ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
			Person p = (Person) obj;
			if (p.getAge() < 0) {
				e.rejectValue("age", "negativevalue");
			} else if (p.getAge() > 110) {
				e.rejectValue("age", "too.darn.old");
			}
		}
	}
----

As you can see, the `static` `rejectIfEmpty(..)` method on the `ValidationUtils` class
is used to reject the `'name'` property if it is `null` or the empty string. Have a look
at the `ValidationUtils` javadocs to see what functionality it provides besides the
example shown previously.

如你所见，`ValidationUtils` 类上的 `static` `rejectIfEmpty(..)` 方法用于拒绝空的或空的字符串的 `'name'` 属性。看看 `ValidationUtils` 的javadocs，除了以前演示的例子，看看它提供了什么功能。

While it is certainly possible to implement a single `Validator` class to validate each
of the nested objects in a rich object, it may be better to encapsulate the validation
logic for each nested class of object in its own `Validator` implementation. A simple
example of a __'rich'__ object would be a `Customer` that is composed of two `String`
properties (a first and second name) and a complex `Address` object. `Address` objects
may be used independently of `Customer` objects, and so a distinct `AddressValidator`
has been implemented. If you want your `CustomerValidator` to reuse the logic contained
within the `AddressValidator` class without resorting to copy-and-paste, you can
dependency-inject or instantiate an `AddressValidator` within your `CustomerValidator`,
and use it like so:

虽然确实可以实现一个 `验证器` 类来验证富对象中的每个嵌套对象，但是将每个嵌套的对象类的验证逻辑封装在其自己的 `验证器` 实现中可能更好。__‘富’__对象的简单示例将是一个 `Customer`，由两个 `String` 属性（第一个和第二个名称）以及一个复杂的 `Address` 对象组成。`Address` 对象可以独立于 `Customer` 对象使用，因此已经实现了一个独特的 `AddressValidator`。如果你想让你的 `CustomerValidator` 重用 `AddressValidator` 类中包含的逻辑，而不需要复制和粘贴，你可以依赖注入或实例化 `CustomerValidator` 中的 `AddressValidator`，并使用它：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class CustomerValidator implements Validator {

		private final Validator addressValidator;

		public CustomerValidator(Validator addressValidator) {
			if (addressValidator == null) {
				throw new IllegalArgumentException("The supplied [Validator] is " +
					"required and must not be null.");
			}
			if (!addressValidator.supports(Address.class)) {
				throw new IllegalArgumentException("The supplied [Validator] must " +
					"support the validation of [Address] instances.");
			}
			this.addressValidator = addressValidator;
		}

		/**
		 * This Validator validates Customer instances, and any subclasses of Customer too
		 */
		public boolean supports(Class clazz) {
			return Customer.class.isAssignableFrom(clazz);
		}

		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
			Customer customer = (Customer) target;
			try {
				errors.pushNestedPath("address");
				ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
			} finally {
				errors.popNestedPath();
			}
		}
	}
----

Validation errors are reported to the `Errors` object passed to the validator. In case
of Spring Web MVC you can use `<spring:bind/>` tag to inspect the error messages, but of
course you can also inspect the errors object yourself. More information about the
methods it offers can be found in the javadocs.

验证错误报告给传递给验证器的 `错误` 对象。在Spring Web MVC的情况下，您可以使用 `<spring:bind/>` 标签来检查错误消息，但是当然你也可以自己检查错误对象。有关其提供的方法的更多信息可以在javadoc中找到。




[[validation-conversion]]
== 解析错误消息的代码(Resolving codes to error messages)
We've talked about databinding and validation. Outputting messages corresponding to
validation errors is the last thing we need to discuss. In the example we've shown
above, we rejected the `name` and the `age` field. If we're going to output the error
messages by using a `MessageSource`, we will do so using the error code we've given when
rejecting the field ('name' and 'age' in this case). When you call (either directly, or
indirectly, using for example the `ValidationUtils` class) `rejectValue` or one of the
other `reject` methods from the `Errors` interface, the underlying implementation will
not only register the code you've passed in, but also a number of additional error
codes. What error codes it registers is determined by the `MessageCodesResolver` that is
used. By default, the `DefaultMessageCodesResolver` is used, which for example not only
registers a message with the code you gave, but also messages that include the field
name you passed to the reject method. So in case you reject a field using
`rejectValue("age", "too.darn.old")`, apart from the `too.darn.old` code, Spring will
also register `too.darn.old.age` and `too.darn.old.age.int` (so the first will include
the field name and the second will include the type of the field); this is done as a
convenience to aid developers in targeting error messages and suchlike.

我们已经讨论了数据绑定和验证。输出与验证错误相对应的消息是我们需要讨论的最后一件事。在我们上面显示的例子中，我们拒绝了 `name` 和 `age` 字段。如果要使用 `MessageSource` 输出错误消息，我们将使用我们在拒绝该字段时给出的错误代码（在这种情况下为'name'和'age'）来做这件事。当您（直接或间接地，例如使用 `ValidationUtils` 类）调用 `rejectValue` 或 `Errors` 接口中的另一个 `reject` 方法时，底层的实现不仅会注册你所使用的代码，还有一些额外的错误代码。它所注册的错误代码由使用的 `MessageCodesResolver` 决定。默认情况下，使用 `DefaultMessageCodesResolver`，例如它不仅注册了您提供的代码的消息，还包括传递给reject方法的字段名称的消息。所以如果你使用 `rejectValue（“age”，“too.darn.old”）` 拒绝一个字段，除了 `too.darn.old` 代码，Spring也会注册 `too.darn.old.age` 和 `too.darn.old.age.int`（所以第一个将包括字段名称，第二个将包括该字段的类型）；这样做是为了方便开发人员定位错误消息等。

More information on the `MessageCodesResolver` and the default strategy can be found
online in the javadocs of
{api-spring-framework}/validation/MessageCodesResolver.html[`MessageCodesResolver`]
and
{api-spring-framework}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`],
respectively.

有关 `MessageCodesResolver` 和默认策略的更多信息可以分别在 {api-spring-framework}/validation/MessageCodesResolver.html[`MessageCodesResolver`] 和 {api-spring-framework}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`] 的javadoc中在线查找。




[[beans-beans]]
== Bean操作和BeanWrapper(Bean manipulation and the BeanWrapper)

The `org.springframework.beans` package adheres to the JavaBeans standard provided by
Oracle. A JavaBean is simply a class with a default no-argument constructor, which follows
a naming convention where (by way of an example) a property named `bingoMadness` would
have a setter method `setBingoMadness(..)` and a getter method `getBingoMadness()`. For
more information about JavaBeans and the specification, please refer to Oracle's website (
http://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html[javabeans]).

`org.springframework.beans` 包遵循Oracle提供的JavaBeans标准。JavaBean只是带有一个默认无参数构造函数的类，它遵循一个命名约定（举个例子）一个名为 `bingoMadness` 的属性将有一个setter方法 `setBingoMadness(..)` 和一个getter方法 `getBingoMadness()`。有关JavaBeans和规范的更多信息，请参阅Oracle的网站(http://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html[javabeans])。

One quite important class in the beans package is the `BeanWrapper` interface and its
corresponding implementation ( `BeanWrapperImpl`). As quoted from the javadocs, the
`BeanWrapper` offers functionality to set and get property values (individually or in
bulk), get property descriptors, and to query properties to determine if they are
readable or writable. Also, the `BeanWrapper` offers support for nested properties,
enabling the setting of properties on sub-properties to an unlimited depth. Then, the
`BeanWrapper` supports the ability to add standard JavaBeans `PropertyChangeListeners`
and `VetoableChangeListeners`, without the need for supporting code in the target class.
Last but not least, the `BeanWrapper` provides support for the setting of indexed
properties. The `BeanWrapper` usually isn't used by application code directly, but by
the `DataBinder` and the `BeanFactory`.

Bean包中的一个相当重要的类是 `BeanWrapper` 接口及其相应的实现（`BeanWrapperImpl`）。就像从javadocs引用的那样，`BeanWrapper` 提供了设置和获取属性值（单独或批量），获取属性描述符和查询属性以确定它们是否可读或可写的功能。此外，`BeanWrapper` 还提供对嵌套属性的支持，可以将子属性的属性设置扩展到无限深度。然后，`BeanWrapper` 支持添加标准JavaBeans的 `PropertyChangeListeners` 和 `VetoableChangeListeners` 的功能，没有对目标类中支持代码的需求。最后但并非最不重要的是，`BeanWrapper` 提供对已索引的属性的设置的支持。`BeanWrapper` 通常不被应用程序代码直接使用，而是由 `DataBinder` 和 `BeanFactory` 使用。

The way the `BeanWrapper` works is partly indicated by its name: __it wraps a bean__ to
perform actions on that bean, like setting and retrieving properties.

`BeanWrapper` 工作的方式部分地由它的名称表示：它包装一个bean以对该bean执行操作，例如设置和检索属性。



[[beans-beans-conventions]]
=== 设置并获取基本和嵌套的属性(Setting and getting basic and nested properties)
Setting and getting properties is done using the `setPropertyValue(s)` and
`getPropertyValue(s)` methods that both come with a couple of overloaded variants.
They're all described in more detail in the javadocs Spring comes with. What's important
to know is that there are a couple of conventions for indicating properties of an
object. A couple of examples:

使用 `setPropertyValue(s)` 和 `getPropertyValue(s)` 方法进行设置和获取属性，这两种方法都带有几个重载变体。它们都在Spring附带的javadocs中有更详细的描述。重要的是有一些指示一个对象属性的约定。几个例子：

[[beans-beans-conventions-properties-tbl]]
.属性的例子(Examples of properties)
|===
| 表达式(Expression)| 解释(Explanation)

| `name`
| 表示属性 `name` 对应于 `getName()` 或 `isName()` 和 `setName(..)` 方法(Indicates the property `name` corresponding to the methods `getName()` or `isName()`
  and `setName(..)`)

| `account.name`
| 表示属性 `account` 的嵌套属性 `name` 对应于（举例来说）方法 `getAccount().setName()` 或 `getAccount().getName()`(Indicates the nested property `name` of the property `account` corresponding e.g. to
  the methods `getAccount().setName()` or `getAccount().getName()`)

| `account[2]`
| 表示已索引的属性 `account` 的__第三个__元素。已索引的属性可以是 `array`，`list` 或其他自然有序集合的类型(Indicates the __third__ element of the indexed property `account`. Indexed properties
  can be of type `array`, `list` or other __naturally ordered__ collection)

| `account[COMPANYNAME]`
| 指示由Map属性 `account` 的__COMPANYNAME__键索引的Map项的值(Indicates the value of the map entry indexed by the key __COMPANYNAME__ of the Map
  property `account`)
|===

Below you'll find some examples of working with the `BeanWrapper` to get and set
properties.

下面你可以找到一些使用 `BeanWrapper` 来获取和设置属性的例子。

__(This next section is not vitally important to you if you're not planning to work with
the `BeanWrapper` directly. If you're just using the `DataBinder` and the `BeanFactory`
and their out-of-the-box implementation, you should skip ahead to the section about
`PropertyEditors`.)__

__（如果您不打算直接使用 `BeanWrapper`，下一节对您来说并不重要。如果您只是使用 `DataBinder` 和 `BeanFactory` 及它们开箱即用的实现，则应该跳过关于 `PropertyEditors` 的部分。）__

Consider the following two classes:

考虑以下两个类：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class Company {

		private String name;
		private Employee managingDirector;

		public String getName() {
			return this.name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public Employee getManagingDirector() {
			return this.managingDirector;
		}

		public void setManagingDirector(Employee managingDirector) {
			this.managingDirector = managingDirector;
		}
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class Employee {

		private String name;

		private float salary;

		public String getName() {
			return this.name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public float getSalary() {
			return salary;
		}

		public void setSalary(float salary) {
			this.salary = salary;
		}
	}
----

The following code snippets show some examples of how to retrieve and manipulate some of
the properties of instantiated `Companies` and `Employees`:

以下代码片段显示了如何检索和操作实例化的 `Companies` 和 `Employees` 的一些属性的示例：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	BeanWrapper company = new BeanWrapperImpl(new Company());
	// setting the company name..
	company.setPropertyValue("name", "Some Company Inc.");
	// ... can also be done like this:
	PropertyValue value = new PropertyValue("name", "Some Company Inc.");
	company.setPropertyValue(value);

	// ok, let's create the director and tie it to the company:
	BeanWrapper jim = new BeanWrapperImpl(new Employee());
	jim.setPropertyValue("name", "Jim Stravinsky");
	company.setPropertyValue("managingDirector", jim.getWrappedInstance());

	// retrieving the salary of the managingDirector through the company
	Float salary = (Float) company.getPropertyValue("managingDirector.salary");
----



[[beans-beans-conversion]]
=== 内置PropertyEditor实现(Built-in PropertyEditor implementations)

Spring uses the concept of `PropertyEditors` to effect the conversion between an
`Object` and a `String`. If you think about it, it sometimes might be handy to be able
to represent properties in a different way than the object itself. For example, a `Date`
can be represented in a human readable way (as the `String` `'2007-14-09'`), while
we're still able to convert the human readable form back to the original date (or even
better: convert any date entered in a human readable form, back to `Date` objects). This
behavior can be achieved by __registering custom editors__, of type
`java.beans.PropertyEditor`. Registering custom editors on a `BeanWrapper` or
alternately in a specific IoC container as mentioned in the previous chapter, gives it
the knowledge of how to convert properties to the desired type. Read more about
`PropertyEditors` in the javadocs of the `java.beans` package provided by Oracle.

Spring使用 `PropertyEditors` 的概念来实现 `Object` 和 `String` 之间的转换。如果你仔细想想，有时不以对象本身而是以一种不同的方式来表示属性可能更得心应手。例如，`Date` 可以用人类可读的方式表示（如 `String` `'2007-14-09'`），而我们仍然可以将人类可读的形式转换回原始日期（甚至更好：将以人类可读形式输入的任何日期转换回 `Date` 对象）。可以通过__注册 `java.beans.PropertyEditor` 类型的自定义编辑器__来实现此行为。在 `BeanWrapper` 中或在上一章中提到的特定IoC容器中注册自定义编辑器，可以了解如何将属性转换为所需类型。在Oracle提供的 `java.beans` 包的javadoc中阅读更多关于 `PropertyEditors` 的信息。

A couple of examples where property editing is used in Spring:

Spring中使用了属性编辑的一些例子：

* __setting properties on beans__ is done using `PropertyEditors`. When mentioning
  `java.lang.String` as the value of a property of some bean you're declaring in XML
  file, Spring will (if the setter of the corresponding property has a
  `Class`-parameter) use the `ClassEditor` to try to resolve the parameter to a `Class`
  object.
* __在bean上设置属性__是使用 `PropertyEditors` 完成的。当把 `java.lang.String` 作为你在XML文件中声明的某个bean的属性的值来提到时，Spring将（如果相应属性的setter有一个 `Class` 参数）使用 `ClassEditor` 尝试将参数解析为一个 `Class` 对象。
* __parsing HTTP request parameters__ in Spring's MVC framework is done using all kinds
  of `PropertyEditors` that you can manually bind in all subclasses of the
  `CommandController`.
* 在Spring的MVC框架中__解析HTTP请求参数__是使用各种 `PropertyEditors` 完成的，您可以在 `CommandController` 的所有子类中手动绑定（PropertyEditors）。

Spring has a number of built-in `PropertyEditors` to make life easy. Each of those is
listed below and they are all located in the `org.springframework.beans.propertyeditors`
package. Most, but not all (as indicated below), are registered by default by
`BeanWrapperImpl`. Where the property editor is configurable in some fashion, you can of
course still register your own variant to override the default one:

Spring有一些内置的 `PropertyEditors`，使生活变得简单。它们中的每一个都列在下面，它们都位于 `org.springframework.beans.propertyeditors` 包中。大多数但不是全部（如下所示），默认情况下由 `BeanWrapperImpl` 注册。在某种情况下，属性编辑器是可配置的，您当然仍然可以注册自己的变体来覆盖默认的变体：

[[beans-beans-property-editors-tbl]]
.内置PropertyEditors(Built-in PropertyEditors)
|===
| 类(Class)| 说明(Explanation)

| `ByteArrayPropertyEditor`
| 字节数组编辑器。字符串将简单地转换为相应的字节表示。由 `BeanWrapperImpl` 默认注册。(Editor for byte arrays. Strings will simply be converted to their corresponding byte
  representations. Registered by default by `BeanWrapperImpl`.)

| `ClassEditor`
| 将字符串表达的类解析为实际的类或将实际的类解析为字符串表达的类。当找不到类时，会抛出一个 `IllegalArgumentException`。由 `BeanWrapperImpl` 默认注册。(Parses Strings representing classes to actual classes and the other way around. When a
  class is not found, an `IllegalArgumentException` is thrown. Registered by default by
  `BeanWrapperImpl`.)

| `CustomBooleanEditor`
| `布尔` 属性的可定制属性编辑器。通过 `BeanWrapperImpl` 默认注册，但可以通过将它的自定义实例注册为自定义编辑器来覆盖。(Customizable property editor for `Boolean` properties. Registered by default by
  `BeanWrapperImpl`, but, can be overridden by registering custom instance of it as
  custom editor.)

| `CustomCollectionEditor`
| 集合的属性编辑器，将任何源 `Collection` 转换为给定的目标 `Collection` 类型。(Property editor for Collections, converting any source `Collection` to a given target
  `Collection` type.)

| `CustomDateEditor`
| 可定制的java.util.Date属性编辑器，支持自定义日期格式。默认情况下未注册。必须由用户根据需要使用适当的格式进行注册。(Customizable property editor for java.util.Date, supporting a custom DateFormat. NOT
  registered by default. Must be user registered as needed with appropriate format.)

| `CustomNumberEditor`
| 任何Number子类的可定制属性编辑器，如 `Integer`，`Long`，`Float`，`Double`。通过 `BeanWrapperImpl` 默认注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。(Customizable property editor for any Number subclass like `Integer`, `Long`, `Float`,
  `Double`. Registered by default by `BeanWrapperImpl`, but can be overridden by
  registering custom instance of it as a custom editor.)

| `FileEditor`
| 能够将字符串解析为 `java.io.File` 对象。由 `BeanWrapperImpl` 默认注册。(Capable of resolving Strings to `java.io.File` objects. Registered by default by
  `BeanWrapperImpl`.)

| `InputStreamEditor`
| 单向属性编辑器，能够获取文本字符串并生成（通过一个中间的 `ResourceEditor` 和 `Resource`）一个 `InputStream`，所以 `InputStream` 属性可以直接设置为字符串。请注意，默认的用法不会为您关闭 `InputStream`！由 `BeanWrapperImpl` 默认注册。(One-way property editor, capable of taking a text string and producing (via an
  intermediate `ResourceEditor` and `Resource`) an `InputStream`, so `InputStream`
  properties may be directly set as Strings. Note that the default usage will not close
  the `InputStream` for you! Registered by default by `BeanWrapperImpl`.)

| `LocaleEditor`
| 能够将字符串解析为 `Locale` 对象，反之亦然（String格式是 [语言]_[国家]_[变体]，这与Locale提供的toString()方法是一样的）。由 `BeanWrapperImpl` 默认注册。(Capable of resolving Strings to `Locale` objects and vice versa (the String format is
  [language]_[country]_[variant], which is the same thing the toString() method of
  Locale provides). Registered by default by `BeanWrapperImpl`.)

| `PatternEditor`
| 能够将字符串解析为 `java.util.regex.Pattern` 对象，反之亦然。(Capable of resolving Strings to `java.util.regex.Pattern` objects and vice versa.)

| `PropertiesEditor`
| 能够转换字符串（使用 `java.util.Properties` 类的javadocs中定义的格式格式化）为 `属性` 对象。由 `BeanWrapperImpl` 默认注册。(Capable of converting Strings (formatted using the format as defined in the javadocs
  of the `java.util.Properties` class) to `Properties` objects. Registered by default
  by `BeanWrapperImpl`.)

| `StringTrimmerEditor`
| 修整字符串的属性编辑器。（可选的）允许将空字符串转换为 `null` 值。默认未注册；必须由用户根据需要进行注册。(Property editor that trims Strings. Optionally allows transforming an empty string
  into a `null` value. NOT registered by default; must be user registered as needed.)

| `URLEditor`
| 能够将URL的String表示解析为实际的 `URL` 对象。由 `BeanWrapperImpl` 默认注册。(Capable of resolving a String representation of a URL to an actual `URL` object.
  Registered by default by `BeanWrapperImpl`.)
|===

Spring uses the `java.beans.PropertyEditorManager` to set the search path for property
editors that might be needed. The search path also includes `sun.bean.editors`, which
includes `PropertyEditor` implementations for types such as `Font`, `Color`, and most of
the primitive types. Note also that the standard JavaBeans infrastructure will
automatically discover `PropertyEditor` classes (without you having to register them
explicitly) if they are in the same package as the class they handle, and have the same
name as that class, with `'Editor'` appended; for example, one could have the following
class and package structure, which would be sufficient for the `FooEditor` class to be
recognized and used as the `PropertyEditor` for `Foo`-typed properties.

Spring使用 `java.beans.PropertyEditorManager` 设置可能需要的属性编辑器的搜索路径。搜索路径还包括 `sun.bean.editors`，其中包含用于 `Font`，`Color` 等类型和大部分原始类型的 `PropertyEditor` 实现。还要注意的是，标准的JavaBeans基础架构将自动发现 `PropertyEditor` 类（你不必明确地注册它们），如果它们与它们处理的类处于同一个包中，并且与该类具有相同的名称，并附加有 `'Editor'`；例如，它可能具有以下类和包结构，这足以使 `FooEditor` 类被识别并用作 `Foo` 类型属性的 `PropertyEditor`。

[literal]
[subs="verbatim,quotes"]
----
com
  chank
    pop
      Foo
      FooEditor // Foo类的PropertyEditor(the PropertyEditor for the Foo class)
----

Note that you can also use the standard `BeanInfo` JavaBeans mechanism here as well
(described
http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html[in
not-amazing-detail here]). Find below an example of using the `BeanInfo` mechanism for
explicitly registering one or more `PropertyEditor` instances with the properties of an
associated class.

请注意，您也可以在这里使用标准的 `BeanInfo` JavaBeans机制（ http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html[在这里不详细的描述]）。在下面的一个示例中，使用 `BeanInfo` 机制显式注册一个相关类的属性的一个或多个 `PropertyEditor` 实例。

[literal]
[subs="verbatim,quotes"]
----
com
  chank
    pop
      Foo
      FooBeanInfo // 用于Foo类的BeanInfo(the BeanInfo for the Foo class)
----

Here is the Java source code for the referenced `FooBeanInfo` class. This would
associate a `CustomNumberEditor` with the `age` property of the `Foo` class.

以下是供参考的 `FooBeanInfo` 类的Java源代码。这将把 `CustomNumberEditor` 与 `Foo` 类的 `age` 属性关联起来。

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class FooBeanInfo extends SimpleBeanInfo {

		public PropertyDescriptor[] getPropertyDescriptors() {
			try {
				final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
				PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Foo.class) {
					public PropertyEditor createPropertyEditor(Object bean) {
						return numberPE;
					};
				};
				return new PropertyDescriptor[] { ageDescriptor };
			}
			catch (IntrospectionException ex) {
				throw new Error(ex.toString());
			}
		}
	}
----


[[beans-beans-conversion-customeditor-registration]]
==== 注册额外的自定义PropertyEditor(Registering additional custom PropertyEditors)

When setting bean properties as a string value, a Spring IoC container ultimately uses
standard JavaBeans `PropertyEditors` to convert these Strings to the complex type of the
property. Spring pre-registers a number of custom `PropertyEditors` (for example, to
convert a classname expressed as a string into a real `Class` object). Additionally,
Java's standard JavaBeans `PropertyEditor` lookup mechanism allows a `PropertyEditor`
for a class simply to be named appropriately and placed in the same package as the class
it provides support for, to be found automatically.

将bean属性设置为字符串值时，Spring IoC容器最终将使用标准的JavaBeans `PropertyEditors` 将这些字符串转换为属性的复杂类型。Spring预先注册了许多自定义的 `PropertyEditors`（例如，将一个表达为一个字符串的类名转换成一个真正的 `Class` 对象）。另外，Java的标准JavaBeans `PropertyEditor` 查找机制允许一个类的 `PropertyEditor` 简单地被适当地命名，并且被放置在与它提供支持的类的相同的包中，以便被自动找到。

If there is a need to register other custom `PropertyEditors`, there are several
mechanisms available. The most manual approach, which is not normally convenient or
recommended, is to simply use the `registerCustomEditor()` method of the
`ConfigurableBeanFactory` interface, assuming you have a `BeanFactory` reference.
Another, slightly more convenient, mechanism is to use a special bean factory
post-processor called `CustomEditorConfigurer`. Although bean factory post-processors
can be used with `BeanFactory` implementations, the `CustomEditorConfigurer` has a
nested property setup, so it is strongly recommended that it is used with the
`ApplicationContext`, where it may be deployed in similar fashion to any other bean, and
automatically detected and applied.

如果需要注册其他自定义的 `PropertyEditors`，可以使用多种机制。假设你有一个 `BeanFactory` 引用，最简单的但通常并不方便或推荐的方法就是简单地使用 `ConfigurableBeanFactory` 接口的 `registerCustomEditor()` 方法。另一个稍微更方便的机制是使用一个名为 `CustomEditorConfigurer` 的特殊的bean工厂后处理器。虽然Bean工厂后处理器可以与 `BeanFactory` 实现一起使用，但 `CustomEditorConfigurer` 具有嵌套的属性设置，因此强烈建议它与 `ApplicationContext` 一起使用，这样它可以以类似的方式部署到任何其他bean，并自动检测并应用。

Note that all bean factories and application contexts automatically use a number of
built-in property editors, through their use of something called a `BeanWrapper` to
handle property conversions. The standard property editors that the `BeanWrapper`
registers are listed in <<beans-beans-conversion,the previous section>>. Additionally,
`ApplicationContexts` also override or add an additional number of editors to handle
resource lookups in a manner appropriate to the specific application context type.

请注意，所有bean工厂和应用程序上下文都会自动使用一些内置的属性编辑器，通过使用一些名为 `BeanWrapper` 的东西来处理属性转换。`BeanWrapper` 注册的标准属性编辑器在<<beans-beans-conversion,上一节>>中列出。另外，`ApplicationContexts` 还可以以适合特定应用程序上下文类型的方式，覆盖或添加额外的编辑器来处理资源查找。

Standard JavaBeans `PropertyEditor` instances are used to convert property values
expressed as strings to the actual complex type of the property.
`CustomEditorConfigurer`, a bean factory post-processor, may be used to conveniently add
support for additional `PropertyEditor` instances to an `ApplicationContext`.

标准JavaBeans `PropertyEditor` 实例用于将表示为字符串的属性值转换为属性的实际复杂类型。`CustomEditorConfigurer` 是一个bean工厂后处理器，可以方便地为 `ApplicationContext` 添加额外的 `PropertyEditor` 实例支持。

Consider a user class `ExoticType`, and another class `DependsOnExoticType` which needs
`ExoticType` set as a property:

考虑一个用户类 `ExoticType`，另一个 `DependsOnExoticType` 类需要 `ExoticType` 作为一个属性设置：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package example;

	public class ExoticType {

		private String name;

		public ExoticType(String name) {
			this.name = name;
		}
	}

	public class DependsOnExoticType {

		private ExoticType type;

		public void setType(ExoticType type) {
			this.type = type;
		}
	}
----

When things are properly set up, we want to be able to assign the type property as a
string, which a `PropertyEditor` will behind the scenes convert into an actual
`ExoticType` instance:

当事情正确设置时，我们希望能够将类型属性分配为一个字符串，在后台 `PropertyEditor` 将（其）转换为实际的 `ExoticType` 实例：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="sample" class="example.DependsOnExoticType">
		<property name="type" value="aNameForExoticType"/>
	</bean>
----

The `PropertyEditor` implementation could look similar to this:

`PropertyEditor` 实现可能类似于：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	// 将字符串表示转换为ExoticType对象包示例；(converts string representation to ExoticType object
	package example;)

	public class ExoticTypeEditor extends PropertyEditorSupport {

		public void setAsText(String text) {
			setValue(new ExoticType(text.toUpperCase()));
		}
	}
----

Finally, we use `CustomEditorConfigurer` to register the new `PropertyEditor` with the
`ApplicationContext`, which will then be able to use it as needed:

最后，我们使用 `CustomEditorConfigurer` 将新的 `PropertyEditor` 在 `ApplicationContext` 中注册，然后可以根据需要使用它：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="customEditors">
			<map>
				<entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
			</map>
		</property>
	</bean>
----

[[beans-beans-conversion-customeditor-registration-per]]
===== 使用PropertyEditorRegistrars(Using PropertyEditorRegistrars)

Another mechanism for registering property editors with the Spring container is to
create and use a `PropertyEditorRegistrar`. This interface is particularly useful when
you need to use the same set of property editors in several different situations: write
a corresponding registrar and reuse that in each case. `PropertyEditorRegistrars` work
in conjunction with an interface called `PropertyEditorRegistry`, an interface that is
implemented by the Spring `BeanWrapper` (and `DataBinder`). `PropertyEditorRegistrars`
are particularly convenient when used in conjunction with the `CustomEditorConfigurer`
(introduced <<beans-beans-conversion-customeditor-registration,here>>), which exposes a
property called `setPropertyEditorRegistrars(..)`: `PropertyEditorRegistrars` added to a
`CustomEditorConfigurer` in this fashion can easily be shared with `DataBinder` and
Spring MVC `Controllers`. Furthermore, it avoids the need for synchronization on custom
editors: a `PropertyEditorRegistrar` is expected to create fresh `PropertyEditor`
instances for each bean creation attempt.

使用Spring容器注册属性编辑器的另一种机制是创建并使用 `PropertyEditorRegistrar`。当您需要在几种不同的情况下使用相同的属性编辑器集时，此接口特别有用：在每种情况下写入相应的注册器并重新使用。`PropertyEditorRegistrars` 与名为 `PropertyEditorRegistry` 的接口配合使用，该接口由Spring `BeanWrapper`（和 `DataBinder`）实现。`PropertyEditorRegistrars` 与 `CustomEditorConfigurer`（在<<beans-beans-conversion-customeditor-registration,这里>>介绍）一起使用时，特别方便，它会公开一个名为 `setPropertyEditorRegistrars(..)` 的属性：以这种方式添加到 `CustomEditorConfigurer` 中的 `PropertyEditorRegistrars` 可以轻松地被与 `DataBinder` 和Spring MVC `Controllers` 共享。此外，它避免了对自定义编辑器的同步需求：`PropertyEditorRegistrar` 预计将为每个创建bean的尝试创建新的 `PropertyEditor` 实例。

Using a `PropertyEditorRegistrar` is perhaps best illustrated with an example. First
off, you need to create your own `PropertyEditorRegistrar` implementation:

使用一个 `PropertyEditorRegistrar` 也许最好用例子说明。首先，您需要创建自己的 `PropertyEditorRegistrar` 实现：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.foo.editors.spring;

	public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

		public void registerCustomEditors(PropertyEditorRegistry registry) {

			// 预期将创建新的PropertyEditor实例(it is expected that new PropertyEditor instances are created)
			registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

			// 您可以在这里任意注册需要的自定义属性编辑器……(you could register as many custom property editors as are required here...)
		}
	}
----

See also the `org.springframework.beans.support.ResourceEditorRegistrar` for an example
`PropertyEditorRegistrar` implementation. Notice how in its implementation of the
`registerCustomEditors(..)` method it creates new instances of each property editor.

另请参见 `org.springframework.beans.support.ResourceEditorRegistrar` 中 `PropertyEditorRegistrar` 的实现的一个例子。请注意，在实现 `registerCustomEditors(..)` 方法时，它将创建每个属性编辑器的新实例。

Next we configure a `CustomEditorConfigurer` and inject an instance of our
`CustomPropertyEditorRegistrar` into it:

接下来我们配置一个 `CustomEditorConfigurer`，并将 `CustomPropertyEditorRegistrar` 的一个实例注入到它中：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<ref bean="customPropertyEditorRegistrar"/>
			</list>
		</property>
	</bean>

	<bean id="customPropertyEditorRegistrar"
		class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
----

Finally, and in a bit of a departure from the focus of this chapter, for those of you
using <<mvc,Spring's MVC web framework>>, using `PropertyEditorRegistrars` in
conjunction with data-binding `Controllers` (such as `SimpleFormController`) can be very
convenient. Find below an example of using a `PropertyEditorRegistrar` in the
implementation of an `initBinder(..)` method:

最后，与本章重点有所偏离，对于那些使用<<mvc,Spring MVC Web框架>>的人，与数据绑定 `Controllers` 一起使用 `PropertyEditorRegistrars`（如 `SimpleFormController`）可以非常方便。在下面的一个示例中，在 `initBinder(..)` 方法的实现中使用 `PropertyEditorRegistrar`：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public final class RegisterUserController extends SimpleFormController {

		private final PropertyEditorRegistrar customPropertyEditorRegistrar;

		public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
			this.customPropertyEditorRegistrar = propertyEditorRegistrar;
		}

		protected void initBinder(HttpServletRequest request,
				ServletRequestDataBinder binder) throws Exception {
			**this.customPropertyEditorRegistrar.registerCustomEditors(binder);**
		}

		// 注册用户的其他方法(other methods to do with registering a User)
	}
----

This style of `PropertyEditor` registration can lead to concise code (the implementation
of `initBinder(..)` is just one line long!), and allows common `PropertyEditor`
registration code to be encapsulated in a class and then shared amongst as many
`Controllers` as needed.

`PropertyEditor` 注册的这种风格可以导致简洁的代码（`initBinder(..)` 的实现只有一行！），并且允许将常见的 `PropertyEditor` 注册代码封装在一个类中，然后在许多 `控制器` 中根据需要共享。




[[core-convert]]
== Spring类型转换(Spring Type Conversion)
Spring 3 introduces a `core.convert` package that provides a general type conversion
system. The system defines an SPI to implement type conversion logic, as well as an API
to execute type conversions at runtime. Within a Spring container, this system can be
used as an alternative to PropertyEditors to convert externalized bean property value
strings to required property types. The public API may also be used anywhere in your
application where type conversion is needed.

Spring 3引入了一个 `core.convert` 包，提供了一个通用的类型转换系统。该系统定义了一个SPI来实现类型转换逻辑，以及一个在运行时执行类型转换的API。在Spring容器中，该系统可以用作PropertyEditor的替代物，以将以字符串形式表达的bean属性值转换为所需的属性类型。公共API也可以在需要类型转换的应用程序的任何地方使用。



[[core-convert-Converter-API]]
=== 转换器SPI(Converter SPI)
The SPI to implement type conversion logic is simple and strongly typed:

实现类型转换逻辑的SPI是简单和强类型的：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface Converter<S, T> {

		T convert(S source);

	}
----

To create your own converter, simply implement the interface above. Parameterize `S`
as the type you are converting from, and `T` as the type you are converting to. Such a
converter can also be applied transparently if a collection or array of `S` needs to be
converted to an array or collection of `T`, provided that a delegating array/collection
converter has been registered as well (which `DefaultConversionService` does by default).

要创建自己的转换器，只需实现上面的接口。将 `S` 作为您要从其转换的类型参数化，将 `T` 作为要转换为的类型。如果需要将 `S` 的集合或数组转换为 `T` 的数组或集合，那么这种转换器也可以透明地应用，前提是已经注册了一个委托数组/集合转换器（`DefaultConversionService` 默认调用的）。

For each call to `convert(S)`, the source argument is guaranteed to be NOT null. Your
Converter may throw any unchecked exception if conversion fails; specifically, an
`IllegalArgumentException` should be thrown to report an invalid source value.
Take care to ensure that your `Converter` implementation is thread-safe.

对于每个对 `convert(S)` 的调用，源参数保证不为空。如果转换失败，转换器可能会抛出任何未经检查的异常；具体来说，应该抛出一个 `IllegalArgumentException` 来报告一个无效的源值。请注意确保您的 `Converter` 实现是线程安全的。

Several converter implementations are provided in the `core.convert.support` package as
a convenience. These include converters from Strings to Numbers and other common types.
Consider `StringToInteger` as an example for a typical `Converter` implementation:

为了方便起见，`core.convert.support` 包中提供了几个转换器实现。这些包括从字符串到数字和其他常见类型的转换器。以 `StringToInteger` 为例，介绍典型的 `Converter` 实现：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert.support;

	final class StringToInteger implements Converter<String, Integer> {

		public Integer convert(String source) {
			return Integer.valueOf(source);
		}

	}
----



[[core-convert-ConverterFactory-SPI]]
=== ConverterFactory
When you need to centralize the conversion logic for an entire class hierarchy, for
example, when converting from String to java.lang.Enum objects, implement
`ConverterFactory`:

当您需要集中整个类层次结构的转换逻辑时，例如，当从String转换为java.lang.Enum对象时，实现 `ConverterFactory`：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface ConverterFactory<S, R> {

		<T extends R> Converter<S, T> getConverter(Class<T> targetType);

	}
----

Parameterize S to be the type you are converting from and R to be the base type defining
the __range__ of classes you can convert to. Then implement getConverter(Class<T>),
where T is a subclass of R.

参数化S为您要转换的类型，R为定义可转换到的类的__范围__的基本类型。然后实现getConverter(Class <T>)，其中T是R的子类。

Consider the `StringToEnum` ConverterFactory as an example:

以 `StringToEnum` ConverterFactory为例：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert.support;

	final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

		public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
			return new StringToEnumConverter(targetType);
		}

		private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

			private Class<T> enumType;

			public StringToEnumConverter(Class<T> enumType) {
				this.enumType = enumType;
			}

			public T convert(String source) {
				return (T) Enum.valueOf(this.enumType, source.trim());
			}
		}
	}
----



[[core-convert-GenericConverter-SPI]]
=== GenericConverter
When you require a sophisticated Converter implementation, consider the GenericConverter
interface. With a more flexible but less strongly typed signature, a GenericConverter
supports converting between multiple source and target types. In addition, a
GenericConverter makes available source and target field context you can use when
implementing your conversion logic. Such context allows a type conversion to be driven
by a field annotation, or generic information declared on a field signature.

当需要复杂的Converter实现时，请考虑GenericConverter接口。GenericConverter具有更灵活但不太强类型的签名，支持在多种源和目标类型之间进行转换。此外，GenericConverter可以提供源和目标字段上下文，您可以在实现转换逻辑时使用。这种上下文允许类型转换由字段注解或在字段签名上声明的通用信息来驱动。

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface GenericConverter {

		public Set<ConvertiblePair> getConvertibleTypes();

		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

	}
----

To implement a GenericConverter, have getConvertibleTypes() return the supported
source->target type pairs. Then implement convert(Object, TypeDescriptor,
TypeDescriptor) to implement your conversion logic. The source TypeDescriptor provides
access to the source field holding the value being converted. The target TypeDescriptor
provides access to the target field where the converted value will be set.

要实现GenericConverter，使getConvertibleTypes()返回支持的源->目标类型对。然后实现convert(Object，TypeDescriptor，TypeDescriptor)来实现你的转换逻辑。源TypeDescriptor提供对保存正在转换的值的源字段的访问。目标TypeDescriptor提供对转换值将被设置到的目标字段的访问。

A good example of a GenericConverter is a converter that converts between a Java Array
and a Collection. Such an ArrayToCollectionConverter introspects the field that declares
the target Collection type to resolve the Collection's element type. This allows each
element in the source array to be converted to the Collection element type before the
Collection is set on the target field.

GenericConverter的一个很好的例子是在Java Array和Collection之间进行转换的转换器。这样一个ArrayToCollectionConverter会内部检查声明目标集合类型的字段以解析集合元素类型。这允许在源数组中的每个元素在目标字段上设置集合之前转换为集合元素类型。

[NOTE]
====
Because GenericConverter is a more complex SPI interface, only use it when you need it.
Favor Converter or ConverterFactory for basic type conversion needs.

因为GenericConverter是一个更复杂的SPI接口，只有当你需要它时才使用它。偏重于使用转换器或ConverterFactory进行基本类型转换的需要。
====


[[core-convert-ConditionalGenericConverter-SPI]]
==== ConditionalGenericConverter
Sometimes you only want a `Converter` to execute if a specific condition holds true. For
example, you might only want to execute a `Converter` if a specific annotation is present
on the target field. Or you might only want to execute a `Converter` if a specific method,
such as a `static valueOf` method, is defined on the target class.
`ConditionalGenericConverter` is the union of the `GenericConverter` and
`ConditionalConverter` interfaces that allows you to define such custom matching criteria:

有时你只需要一个特定的条件成立时，一个 `转换器` 才会执行。例如，您可能只想在目标字段中存在特定注解时，才需要执行 `转换器`。或者，您可能只想在目标类上定义了一个特定的方法，例如 `static valueOf` 方法时，才执行一个 `转换器`。`ConditionalGenericConverter` 是 `GenericConverter` 和 `ConditionalConverter` 接口的联合，它允许你定义这样的自定义匹配条件：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface ConditionalGenericConverter
	        extends GenericConverter, ConditionalConverter {

		boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);

	}
----

A good example of a `ConditionalGenericConverter` is an EntityConverter that converts
between an persistent entity identifier and an entity reference. Such a EntityConverter
might only match if the target entity type declares a static finder method e.g.
`findAccount(Long)`. You would perform such a finder method check in the implementation of
`matches(TypeDescriptor, TypeDescriptor)`.

`ConditionalGenericConverter` 的一个很好的例子是一个EntityConverter，它在持久性实体标识符和实体引用之间进行转换。此类EntityConverter可能仅在目标实体类型声明有静态查找器方法（例如：`findAccount(Long)`）时匹配。您将在 `matches(TypeDescriptor，TypeDescriptor)` 的实现中执行这样一个finder方法检查。



[[core-convert-ConversionService-API]]
=== ConversionService API
The ConversionService defines a unified API for executing type conversion logic at
runtime. Converters are often executed behind this facade interface:

ConversionService定义了一个用于在运行时执行类型转换逻辑的统一API。转换器通常在这个表面接口后执行：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.core.convert;

	public interface ConversionService {

		boolean canConvert(Class<?> sourceType, Class<?> targetType);

		<T> T convert(Object source, Class<T> targetType);

		boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

	}
----

Most ConversionService implementations also implement `ConverterRegistry`, which
provides an SPI for registering converters. Internally, a ConversionService
implementation delegates to its registered converters to carry out type conversion logic.

大多数ConversionService实现还实现了 `ConverterRegistry`，它提供了一个用于注册转换器的SPI。在内部，ConversionService实现委托给其注册的转换器来执行类型转换逻辑。

A robust ConversionService implementation is provided in the `core.convert.support`
package. `GenericConversionService` is the general-purpose implementation suitable for
use in most environments. `ConversionServiceFactory` provides a convenient factory for
creating common ConversionService configurations.

`core.convert.support` 包中提供了强大的ConversionService实现。`GenericConversionService` 是适用于大多数环境的通用实现。`ConversionServiceFactory` 为创建常用的ConversionService配置提供了便利的工厂。



[[core-convert-Spring-config]]
=== Configuring a ConversionService
A ConversionService is a stateless object designed to be instantiated at application
startup, then shared between multiple threads. In a Spring application, you typically
configure a ConversionService instance per Spring container (or ApplicationContext).
That ConversionService will be picked up by Spring and then used whenever a type
conversion needs to be performed by the framework. You may also inject this
ConversionService into any of your beans and invoke it directly.

[NOTE]
====
If no ConversionService is registered with Spring, the original PropertyEditor-based
system is used.
====

To register a default ConversionService with Spring, add the following bean definition
with id `conversionService`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="conversionService"
		class="org.springframework.context.support.ConversionServiceFactoryBean"/>
----

A default ConversionService can convert between strings, numbers, enums, collections,
maps, and other common types. To supplement or override the default converters with your
own custom converter(s), set the `converters` property. Property values may implement
either of the Converter, ConverterFactory, or GenericConverter interfaces.

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="conversionService"
			class="org.springframework.context.support.ConversionServiceFactoryBean">
		<property name="converters">
			<set>
				<bean class="example.MyCustomConverter"/>
			</set>
		</property>
	</bean>
----

It is also common to use a ConversionService within a Spring MVC application. See
<<mvc-config-conversion>> in the Spring MVC chapter.

In certain situations you may wish to apply formatting during conversion. See
<<format-FormatterRegistry-SPI>> for details on using
`FormattingConversionServiceFactoryBean`.



[[core-convert-programmatic-usage]]
=== Using a ConversionService programmatically
To work with a ConversionService instance programmatically, simply inject a reference to
it like you would for any other bean:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Service
	public class MyService {

		@Autowired
		public MyService(ConversionService conversionService) {
			this.conversionService = conversionService;
		}

		public void doIt() {
			this.conversionService.convert(...)
		}
	}
----

For most use cases, the `convert` method specifying the _targetType_ can be used but it
will not work with more complex types such as a collection of a parameterized element.
If you want to convert a `List` of `Integer` to a `List` of `String` programmatically,
for instance, you need to provide a formal definition of the source and target types.

Fortunately, `TypeDescriptor` provides various options to make that straightforward:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	DefaultConversionService cs = new DefaultConversionService();

	List<Integer> input = ....
	cs.convert(input,
		TypeDescriptor.forObject(input), // List<Integer> type descriptor
		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
----

Note that `DefaultConversionService` registers converters automatically which are
appropriate for most environments. This includes collection converters, scalar
converters, and also basic `Object` to `String` converters. The same converters can
be registered with any `ConverterRegistry` using the _static_ `addDefaultConverters`
method on the `DefaultConversionService` class.

Converters for value types will be reused for arrays and collections, so there is
no need to create a specific converter to convert from a `Collection` of `S` to a
`Collection` of `T`, assuming that standard collection handling is appropriate.




[[format]]
== Spring Field Formatting
As discussed in the previous section, <<core-convert, `core.convert`>> is a
general-purpose type conversion system. It provides a unified ConversionService API as
well as a strongly-typed Converter SPI for implementing conversion logic from one type
to another. A Spring Container uses this system to bind bean property values. In
addition, both the Spring Expression Language (SpEL) and DataBinder use this system to
bind field values. For example, when SpEL needs to coerce a `Short` to a `Long` to
complete an `expression.setValue(Object bean, Object value)` attempt, the core.convert
system performs the coercion.

Now consider the type conversion requirements of a typical client environment such as a
web or desktop application. In such environments, you typically convert __from String__
to support the client postback process, as well as back __to String__ to support the
view rendering process. In addition, you often need to localize String values. The more
general __core.convert__ Converter SPI does not address such __formatting__ requirements
directly. To directly address them, Spring 3 introduces a convenient Formatter SPI that
provides a simple and robust alternative to PropertyEditors for client environments.

In general, use the Converter SPI when you need to implement general-purpose type
conversion logic; for example, for converting between a java.util.Date and and
java.lang.Long. Use the Formatter SPI when you're working in a client environment, such
as a web application, and need to parse and print localized field values. The
ConversionService provides a unified type conversion API for both SPIs.



[[format-Formatter-SPI]]
=== Formatter SPI
The Formatter SPI to implement field formatting logic is simple and strongly typed:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface Formatter<T> extends Printer<T>, Parser<T> {
	}
----

Where Formatter extends from the Printer and Parser building-block interfaces:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface Printer<T> {
		String print(T fieldValue, Locale locale);
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import java.text.ParseException;

	public interface Parser<T> {
		T parse(String clientValue, Locale locale) throws ParseException;
	}
----

To create your own Formatter, simply implement the Formatter interface above.
Parameterize T to be the type of object you wish to format, for example,
`java.util.Date`. Implement the `print()` operation to print an instance of T for
display in the client locale. Implement the `parse()` operation to parse an instance of
T from the formatted representation returned from the client locale. Your Formatter
should throw a ParseException or IllegalArgumentException if a parse attempt fails. Take
care to ensure your Formatter implementation is thread-safe.

Several Formatter implementations are provided in `format` subpackages as a convenience.
The `number` package provides a `NumberFormatter`, `CurrencyFormatter`, and
`PercentFormatter` to format `java.lang.Number` objects using a `java.text.NumberFormat`.
The `datetime` package provides a `DateFormatter` to format `java.util.Date` objects with
a `java.text.DateFormat`. The `datetime.joda` package provides comprehensive datetime
formatting support based on the http://joda-time.sourceforge.net[Joda Time library].

Consider `DateFormatter` as an example `Formatter` implementation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.format.datetime;

	public final class DateFormatter implements Formatter<Date> {

		private String pattern;

		public DateFormatter(String pattern) {
			this.pattern = pattern;
		}

		public String print(Date date, Locale locale) {
			if (date == null) {
				return "";
			}
			return getDateFormat(locale).format(date);
		}

		public Date parse(String formatted, Locale locale) throws ParseException {
			if (formatted.length() == 0) {
				return null;
			}
			return getDateFormat(locale).parse(formatted);
		}

		protected DateFormat getDateFormat(Locale locale) {
			DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
			dateFormat.setLenient(false);
			return dateFormat;
		}

	}
----

The Spring team welcomes community-driven `Formatter` contributions; see
https://jira.spring.io/browse/SPR[jira.spring.io] to contribute.



[[format-CustomFormatAnnotations]]
=== Annotation-driven Formatting
As you will see, field formatting can be configured by field type or annotation. To bind
an Annotation to a formatter, implement AnnotationFormatterFactory:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface AnnotationFormatterFactory<A extends Annotation> {

		Set<Class<?>> getFieldTypes();

		Printer<?> getPrinter(A annotation, Class<?> fieldType);

		Parser<?> getParser(A annotation, Class<?> fieldType);

	}
----

Parameterize A to be the field annotationType you wish to associate formatting logic
with, for example `org.springframework.format.annotation.DateTimeFormat`. Have
`getFieldTypes()` return the types of fields the annotation may be used on. Have
`getPrinter()` return a Printer to print the value of an annotated field. Have
`getParser()` return a Parser to parse a clientValue for an annotated field.

The example AnnotationFormatterFactory implementation below binds the @NumberFormat
Annotation to a formatter. This annotation allows either a number style or pattern to be
specified:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public final class NumberFormatAnnotationFormatterFactory
			implements AnnotationFormatterFactory<NumberFormat> {

		public Set<Class<?>> getFieldTypes() {
			return new HashSet<Class<?>>(asList(new Class<?>[] {
				Short.class, Integer.class, Long.class, Float.class,
				Double.class, BigDecimal.class, BigInteger.class }));
		}

		public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		}

		public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		}

		private Formatter<Number> configureFormatterFrom(NumberFormat annotation,
				Class<?> fieldType) {
			if (!annotation.pattern().isEmpty()) {
				return new NumberFormatter(annotation.pattern());
			} else {
				Style style = annotation.style();
				if (style == Style.PERCENT) {
					return new PercentFormatter();
				} else if (style == Style.CURRENCY) {
					return new CurrencyFormatter();
				} else {
					return new NumberFormatter();
				}
			}
		}
	}
----

To trigger formatting, simply annotate fields with @NumberFormat:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyModel {

		@NumberFormat(style=Style.CURRENCY)
		private BigDecimal decimal;

	}
----


[[format-annotations-api]]
==== Format Annotation API
A portable format annotation API exists in the `org.springframework.format.annotation`
package. Use @NumberFormat to format java.lang.Number fields. Use @DateTimeFormat to
format java.util.Date, java.util.Calendar, java.util.Long, or Joda Time fields.

The example below uses @DateTimeFormat to format a java.util.Date as a ISO Date
(yyyy-MM-dd):

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyModel {

		@DateTimeFormat(iso=ISO.DATE)
		private Date date;

	}
----



[[format-FormatterRegistry-SPI]]
=== FormatterRegistry SPI
The FormatterRegistry is an SPI for registering formatters and converters.
`FormattingConversionService` is an implementation of FormatterRegistry suitable for
most environments. This implementation may be configured programmatically or
declaratively as a Spring bean using `FormattingConversionServiceFactoryBean`. Because
this implementation also implements `ConversionService`, it can be directly configured
for use with Spring's DataBinder and the Spring Expression Language (SpEL).

Review the FormatterRegistry SPI below:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface FormatterRegistry extends ConverterRegistry {

		void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);

		void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);

		void addFormatterForFieldType(Formatter<?> formatter);

		void addFormatterForAnnotation(AnnotationFormatterFactory<?, ?> factory);

	}
----

As shown above, Formatters can be registered by fieldType or annotation.

The FormatterRegistry SPI allows you to configure Formatting rules centrally, instead of
duplicating such configuration across your Controllers. For example, you might want to
enforce that all Date fields are formatted a certain way, or fields with a specific
annotation are formatted in a certain way. With a shared FormatterRegistry, you define
these rules once and they are applied whenever formatting is needed.



[[format-FormatterRegistrar-SPI]]
=== FormatterRegistrar SPI
The FormatterRegistrar is an SPI for registering formatters and converters through the
FormatterRegistry:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface FormatterRegistrar {

		void registerFormatters(FormatterRegistry registry);

	}
----

A FormatterRegistrar is useful when registering multiple related converters and
formatters for a given formatting category, such as Date formatting. It can also be
useful where declarative registration is insufficient. For example when a formatter
needs to be indexed under a specific field type different from its own <T> or when
registering a Printer/Parser pair. The next section provides more information on
converter and formatter registration.



[[format-configuring-formatting-mvc]]
=== Configuring Formatting in Spring MVC

See <<mvc-config-conversion>> in the Spring MVC chapter.




[[format-configuring-formatting-globaldatetimeformat]]
== Configuring a global date & time format
By default, date and time fields that are not annotated with `@DateTimeFormat` are
converted from strings using the `DateFormat.SHORT` style. If you prefer, you can
change this by defining your own global format.

You will need to ensure that Spring does not register default formatters, and instead
you should register all formatters manually. Use the
`org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar` or
`org.springframework.format.datetime.DateFormatterRegistrar` class depending on whether
you use the Joda Time library.

For example, the following Java configuration will register a global ' `yyyyMMdd`'
format. This example does not depend on the Joda Time library:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	public class AppConfig {

		@Bean
		public FormattingConversionService conversionService() {

			// Use the DefaultFormattingConversionService but do not register defaults
			DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

			// Ensure @NumberFormat is still supported
			conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

			// Register date conversion with a specific global format
			DateFormatterRegistrar registrar = new DateFormatterRegistrar();
			registrar.setFormatter(new DateFormatter("yyyyMMdd"));
			registrar.registerFormatters(conversionService);

			return conversionService;
		}
	}
----

If you prefer XML based configuration you can use a
`FormattingConversionServiceFactoryBean`. Here is the same example, this time using Joda
Time:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd>

		<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
			<property name="registerDefaultFormatters" value="false" />
			<property name="formatters">
				<set>
					<bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" />
				</set>
			</property>
			<property name="formatterRegistrars">
				<set>
					<bean class="org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar">
						<property name="dateFormatter">
							<bean class="org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean">
								<property name="pattern" value="yyyyMMdd"/>
							</bean>
						</property>
					</bean>
				</set>
			</property>
		</bean>
	</beans>
----

[NOTE]
====
Joda Time provides separate distinct types to represent `date`, `time` and `date-time`
values. The `dateFormatter`, `timeFormatter` and `dateTimeFormatter` properties of the
`JodaTimeFormatterRegistrar` should be used to configure the different formats for each
type. The `DateTimeFormatterFactoryBean` provides a convenient way to create formatters.
====

If you are using Spring MVC remember to explicitly configure the conversion service that
is used. For Java based `@Configuration` this means extending the
`WebMvcConfigurationSupport` class and overriding the `mvcConversionService()` method.
For XML you should use the `'conversion-service'` attribute of the
`mvc:annotation-driven` element. See <<mvc-config-conversion>> for details.




[[validation-beanvalidation]]
== Spring Validation
Spring 3 introduces several enhancements to its validation support. First, the JSR-303
Bean Validation API is now fully supported. Second, when used programmatically, Spring's
DataBinder can now validate objects as well as bind to them. Third, Spring MVC now has
support for declaratively validating `@Controller` inputs.



[[validation-beanvalidation-overview]]
=== Overview of the JSR-303 Bean Validation API
JSR-303 standardizes validation constraint declaration and metadata for the Java
platform. Using this API, you annotate domain model properties with declarative
validation constraints and the runtime enforces them. There are a number of built-in
constraints you can take advantage of. You may also define your own custom constraints.

To illustrate, consider a simple PersonForm model with two properties:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class PersonForm {
		private String name;
		private int age;
	}
----

JSR-303 allows you to define declarative validation constraints against such properties:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class PersonForm {

		@NotNull
		@Size(max=64)
		private String name;

		@Min(0)
		private int age;

	}
----

When an instance of this class is validated by a JSR-303 Validator, these constraints
will be enforced.

For general information on JSR-303/JSR-349, see the http://beanvalidation.org/[Bean
Validation website]. For information on the specific capabilities of the default
reference implementation, see the https://www.hibernate.org/412.html[Hibernate
Validator] documentation. To learn how to setup a Bean Validation provider as a Spring
bean, keep reading.



[[validation-beanvalidation-spring]]
=== Configuring a Bean Validation Provider
Spring provides full support for the Bean Validation API. This includes convenient
support for bootstrapping a JSR-303/JSR-349 Bean Validation provider as a Spring bean.
This allows for a `javax.validation.ValidatorFactory` or `javax.validation.Validator` to
be injected wherever validation is needed in your application.

Use the `LocalValidatorFactoryBean` to configure a default Validator as a Spring bean:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="validator"
		class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
----

The basic configuration above will trigger Bean Validation to initialize using its
default bootstrap mechanism. A JSR-303/JSR-349 provider, such as Hibernate Validator,
is expected to be present in the classpath and will be detected automatically.


[[validation-beanvalidation-spring-inject]]
==== Injecting a Validator
`LocalValidatorFactoryBean` implements both `javax.validation.ValidatorFactory` and
`javax.validation.Validator`, as well as Spring's
`org.springframework.validation.Validator`. You may inject a reference to either of
these interfaces into beans that need to invoke validation logic.

Inject a reference to `javax.validation.Validator` if you prefer to work with the Bean
Validation API directly:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import javax.validation.Validator;

	@Service
	public class MyService {

		@Autowired
		private Validator validator;
----

Inject a reference to `org.springframework.validation.Validator` if your bean requires
the Spring Validation API:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.validation.Validator;

	@Service
	public class MyService {

		@Autowired
		private Validator validator;

	}
----


[[validation-beanvalidation-spring-constraints]]
==== Configuring Custom Constraints
Each Bean Validation constraint consists of two parts. First, a `@Constraint` annotation
that declares the constraint and its configurable properties. Second, an implementation
of the `javax.validation.ConstraintValidator` interface that implements the constraint's
behavior. To associate a declaration with an implementation, each `@Constraint` annotation
references a corresponding ValidationConstraint implementation class. At runtime, a
`ConstraintValidatorFactory` instantiates the referenced implementation when the
constraint annotation is encountered in your domain model.

By default, the `LocalValidatorFactoryBean` configures a `SpringConstraintValidatorFactory`
that uses Spring to create ConstraintValidator instances. This allows your custom
ConstraintValidators to benefit from dependency injection like any other Spring bean.

Shown below is an example of a custom `@Constraint` declaration, followed by an associated
`ConstraintValidator` implementation that uses Spring for dependency injection:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Target({ElementType.METHOD, ElementType.FIELD})
	@Retention(RetentionPolicy.RUNTIME)
	@Constraint(validatedBy=MyConstraintValidator.class)
	public @interface MyConstraint {
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import javax.validation.ConstraintValidator;

	public class MyConstraintValidator implements ConstraintValidator {

		@Autowired;
		private Foo aDependency;

		...
	}
----

As you can see, a ConstraintValidator implementation may have its dependencies
@Autowired like any other Spring bean.


[[validation-beanvalidation-spring-method]]
==== Spring-driven Method Validation
The method validation feature supported by Bean Validation 1.1, and as a custom
extension also by Hibernate Validator 4.3, can be integrated into a Spring context
through a `MethodValidationPostProcessor` bean definition:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
----

In order to be eligible for Spring-driven method validation, all target classes need
to be annotated with Spring's `@Validated` annotation, optionally declaring the
validation groups to use. Check out the `MethodValidationPostProcessor` javadocs
for setup details with Hibernate Validator and Bean Validation 1.1 providers.


[[validation-beanvalidation-spring-other]]
==== Additional Configuration Options
The default `LocalValidatorFactoryBean` configuration should prove sufficient for most
cases. There are a number of configuration options for various Bean Validation
constructs, from message interpolation to traversal resolution. See the
`LocalValidatorFactoryBean` javadocs for more information on these options.



[[validation-binder]]
=== Configuring a DataBinder
Since Spring 3, a DataBinder instance can be configured with a Validator. Once
configured, the Validator may be invoked by calling `binder.validate()`. Any validation
Errors are automatically added to the binder's BindingResult.

When working with the DataBinder programmatically, this can be used to invoke validation
logic after binding to a target object:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	Foo target = new Foo();
	DataBinder binder = new DataBinder(target);
	binder.setValidator(new FooValidator());

	// bind to the target object
	binder.bind(propertyValues);

	// validate the target object
	binder.validate();

	// get BindingResult that includes any validation errors
	BindingResult results = binder.getBindingResult();
----

A DataBinder can also be configured with multiple `Validator` instances via
`dataBinder.addValidators` and `dataBinder.replaceValidators`. This is useful when
combining globally configured Bean Validation with a Spring `Validator` configured
locally on a DataBinder instance. See <<validation-mvc-configuring>>.



[[validation-mvc]]
=== Spring MVC 3 Validation

See <<mvc-config-validation>> in the Spring MVC chapter.

